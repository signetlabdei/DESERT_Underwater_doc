<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DESERT: Developer guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DESERT<span id="projectnumber">&#160;3.6.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('DEV.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Developer guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="desstruct"></a>
DESERT Structure</h1>
<p>The DESERT underwater framework is an extension of <a href="https://signet.dei.unipd.it/dgt/ns/miracle/doxygen/index.html">ns-miracle</a>, thus it inherits its modular structure and can directly use all the modules of such framework. Each DESERT module extends from the ns-miracle class Module, which in turn extends from the class PlugIn. They provide basic APIs to (i) send packets to upper/lower layers, (ii) communicate via crosslayer messages with other layers of the stack and (iii) configure the layer via tcl script (command and bind).</p>
<p>The folder structure is composed by two main folders: DESERT_Framework and DESERT_Addons. Inside the former, you find all the modules organized according to the ISO/OSI stack and the installer folder. While the latter contains external modules which doesn't necessarily fit inside the ISO/OSI stack and/or the DESERT core.</p>
<h1><a class="anchor" id="howtcl"></a>
How to create a new tcl script</h1>
<p>In this section we describe how to write a basic DESERT tcl script, following the structure of the tcl found in <code>DESERT/samples/desert_samples/test_uwcbr.tcl</code>.</p>
<p>It is a good practice to start your script with a brief description and a simple draw of the simulated network topology: </p><div class="fragment"><div class="line"># ----------------------------------------------------------------------------------</div>
<div class="line"># This script depicts a very simple but complete stack in which two nodes send data</div>
<div class="line"># to a common sink. The second node is used by the first one as a relay to send data to the sink.</div>
<div class="line"># The routes are configured by using UW/STATICROUTING.</div>
<div class="line"># The application used to generate data is UW/CBR.</div>
<div class="line"># ----------------------------------------------------------------------------------</div>
<div class="line"># ----------------------------------------------------------------------------------</div>
<div class="line"># Stack</div>
<div class="line">#             Node 1                         Node 2                        Sink</div>
<div class="line">#   +--------------------------+   +--------------------------+   +-------------+------------+</div>
<div class="line">#   |  7. UW/CBR               |   |  7. UW/CBR               |   |  7. UW/CBR  | UW/CBR     |</div>
<div class="line">#   +--------------------------+   +--------------------------+   +-------------+------------+</div>
<div class="line">#   |  6. UW/UDP               |   |  6. UW/UDP               |   |  6. UW/UDP               |</div>
<div class="line">#   +--------------------------+   +--------------------------+   +--------------------------+</div>
<div class="line">#   |  5. UW/STATICROUTING     |   |  5. UW/STATICROUTING     |   |  5. UW/STATICROUTING     |</div>
<div class="line">#   +--------------------------+   +--------------------------+   +--------------------------+</div>
<div class="line">#   |  4. UW/IP                |   |  4. UW/IP                |   |  4. UW/IP                |</div>
<div class="line">#   +--------------------------+   +--------------------------+   +--------------------------+</div>
<div class="line">#   |  3. UW/MLL               |   |  3. UW/MLL               |   |  3. UW/MLL               |</div>
<div class="line">#   +--------------------------+   +--------------------------+   +--------------------------+</div>
<div class="line">#   |  2. UW/CSMA_ALOHA        |   |  2. UW/CSMA_ALOHA        |   |  2. UW/CSMA_ALOHA        |</div>
<div class="line">#   +--------------------------+   +--------------------------+   +--------------------------+</div>
<div class="line">#   |  1. Module/MPhy/BPSK     |   |  1. Module/MPhy/BPSK     |   |  1. Module/MPhy/BPSK     |</div>
<div class="line">#   +--------------------------+   +--------------------------+   +--------------------------+</div>
<div class="line">#            |         |                    |         |                   |         |       </div>
<div class="line">#   +----------------------------------------------------------------------------------------+</div>
<div class="line">#   |                                     UnderwaterChannel                                  |</div>
<div class="line">#   +----------------------------------------------------------------------------------------+</div>
</div><!-- fragment --><p>The first thing to do in order to have a working script, is to import the libraries. Note that the order matters and is often a cause of errors. You first need to import the ns-miracle libraries in the following order: </p><div class="fragment"><div class="line">load libMiracle.so</div>
<div class="line">load libMiracleBasicMovement.so</div>
<div class="line">load libmphy.so</div>
<div class="line">load libmmac.so</div>
<div class="line">load libUwmStd.so</div>
</div><!-- fragment --><p> Afterwards you can import DESERT libraries you need (in order). </p><div class="fragment"><div class="line">load libuwcsmaaloha.so</div>
<div class="line">load libuwip.so</div>
<div class="line">load libuwstaticrouting.so</div>
<div class="line">load libuwmll.so</div>
<div class="line">load libuwudp.so</div>
<div class="line">load libuwcbr.so</div>
</div><!-- fragment --><p>In order to configure your simulation, some options and variables may be needed. A common approach is to use an associative array called. These options may be hardcoded or given to the simulation as bash parameters. </p><div class="fragment"><div class="line">set opt(bash_parameters) 0; # Set to 1 to activate bash parameters</div>
<div class="line">if {$opt(bash_parameters)} {</div>
<div class="line">    if {$argc != 2} {</div>
<div class="line">        puts &quot;The script requires two inputs&quot;</div>
<div class="line">    } else {</div>
<div class="line">        set opt(pktsize)    [lindex $argv 0]</div>
<div class="line">        set opt(rngstream)  [lindex $argv 1]</div>
<div class="line">    } else {</div>
<div class="line">        set opt(pktsize)    125;    # Bytes</div>
<div class="line">        set opt(rngstream)  1;      # Needed by the RNG </div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Common simulation options are listed below </p><div class="fragment"><div class="line">set opt(nn) 2.0 ;# Number of Nodes</div>
<div class="line">set opt(starttime) 1</div>
<div class="line">set opt(stoptime) 1000</div>
<div class="line">set opt(duration) [expr $opt(stoptime) - $opt(starttime)]</div>
</div><!-- fragment --><p>Once you have all the needed libraries and options, you need to initialize the ns-miracle simulator and set the random number generator. </p><div class="fragment"><div class="line">set ns [new Simulator]</div>
<div class="line">$ns use-Miracle</div>
<div class="line"> </div>
<div class="line"># Set the default random number generator</div>
<div class="line">global defaultRNG</div>
<div class="line">for {set k 0} {$k &lt; $opt(rngstream)} {incr k} {</div>
<div class="line">    $defaultRNG next-substream</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next there are the binding of the modules. Here you can set globally the initialization values of the binded variables. </p><div class="fragment"><div class="line">Module/UW/CBR set packetSize_       $opt(pktsize)</div>
<div class="line"># ...</div>
</div><!-- fragment --><p>Now you are ready to define a tcl procedure (function) that allows you to create as many different kind of nodes in the network. Inside this procedure, you need to create a ns-miracle node and add the modules you need (the whole protocol stack) and configure them. Optionally you can initialize and set the node position. </p><div class="fragment"><div class="line">proc createNode { id } {</div>
<div class="line">    # include global variables to use in the procedure</div>
<div class="line">    global &lt;variables list&gt;</div>
<div class="line"> </div>
<div class="line">    # build the NS-Miracle node</div>
<div class="line">    set node($id) [$ns create-M_Node $opt(tracefile) $opt(cltracefile)]</div>
<div class="line"> </div>
<div class="line">    # define the module(s) you want to put in the node</div>
<div class="line">    set cbr($id)  [new Module/UW/CBR]</div>
<div class="line">    set udp($id)  [new Module/UW/UDP]</div>
<div class="line">    set ipif($id) [new Module/UW/StaticRouting]</div>
<div class="line">    set ipr($id)  [new Module/UW/IP]</div>
<div class="line">    set mll($id)  [new Module/UW/MLL]</div>
<div class="line">    # ...</div>
<div class="line"> </div>
<div class="line">    # insert the module(s) into the node </div>
<div class="line">    # $node addModule &lt;layer&gt; &lt;module&gt; &lt;cl_trace&gt; &lt;tag&gt;</div>
<div class="line">    $node($id) addModule 7 $cbr($id) 0 &quot;CBR&quot;</div>
<div class="line">    # ...</div>
<div class="line"> </div>
<div class="line">    # intra-node module connections</div>
<div class="line">    # $node setConnection &lt;upper&gt; &lt;lower&gt; &lt;trace&gt;</div>
<div class="line">    $node($id) setConnection $cbr($id) $udp($id) 0</div>
<div class="line">    # ...</div>
<div class="line"> </div>
<div class="line">    # socket configuration</div>
<div class="line">    set portnum($id) [$udp($id) assignPort $cbr($id) ]</div>
<div class="line">    $ipif($id) addr  [expr ($id) + 1]</div>
<div class="line"> </div>
<div class="line">    # add node positions (optional)  </div>
<div class="line">    set position($id) [new &quot;Position/BM&quot;]</div>
<div class="line">    $node($id) addPosition $position($id)</div>
<div class="line">    $position($id) setX_ 0</div>
<div class="line">    $position($id) setY_ 0</div>
<div class="line">    $position($id) setZ_ -100</div>
<div class="line"> </div>
<div class="line">    # ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>You can have as many procedures you want. Typically there is a specific procedure for the sink node (a node which only receives packets). Finally, to actually create the nodes you need to call the procedure. Suppose to have <code>$opt(nn)</code> nodes in the network, you can do: </p><div class="fragment"><div class="line">for {set id 0} {$id &lt; $opt(nn)} {incr id}</div>
<div class="line">{</div>
<div class="line">    createNode $id</div>
<div class="line">}</div>
<div class="line">createSink; # Suppose to have a procedure to create the sink node</div>
</div><!-- fragment --><p>Once you created the nodes you need to connect them, setup the routes and fill the arp tables. </p><div class="fragment"><div class="line">proc connectNodes {id1} {</div>
<div class="line">    global ipif ipr portnum cbr cbr_sink ipif_sink portnum_sink ipr_sink</div>
<div class="line"> </div>
<div class="line">    $cbr($id1) set destAddr_ [$ipif_sink addr]</div>
<div class="line">    $cbr($id1) set destPort_ $portnum_sink($id1)</div>
<div class="line">    $cbr_sink($id1) set destAddr_ [$ipif($id1) addr]</div>
<div class="line">    $cbr_sink($id1) set destPort_ $portnum($id1)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"># Setup flows</div>
<div class="line">for {set id1 0} {$id1 &lt; $opt(nn)} {incr id1}  {</div>
<div class="line">    connectNodes $id1</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"># Fill ARP tables</div>
<div class="line">for {set id1 0} {$id1 &lt; $opt(nn)} {incr id1}  {</div>
<div class="line">    for {set id2 0} {$id2 &lt; $opt(nn)} {incr id2}  {</div>
<div class="line">      $mll($id1) addentry [$ipif($id2) addr] [$mac($id2) addr]</div>
<div class="line">    }   </div>
<div class="line">    $mll($id1) addentry [$ipif_sink addr] [ $mac_sink addr]</div>
<div class="line">    $mll_sink addentry [$ipif($id1) addr] [ $mac($id1) addr]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"># Setup routing table</div>
<div class="line">$ipr(0) addRoute [$ipif_sink addr] [$ipif(1) addr]</div>
<div class="line">$ipr(1) addRoute [$ipif_sink addr] [$ipif_sink addr]</div>
</div><!-- fragment --><p>Finally you need to start and stop the modules and the simulation. </p><div class="fragment"><div class="line">for {set id1 0} {$id1 &lt; $opt(nn)} {incr id1} {</div>
<div class="line">    $ns at $opt(starttime) &quot;$cbr($id1) start&quot;</div>
<div class="line">    $ns at $opt(stoptime) &quot;$cbr($id1) stop&quot;</div>
<div class="line"> </div>
<div class="line">    # ...</div>
<div class="line"> </div>
<div class="line">    $ns at $opt(stoptime)  &quot;finish; $ns halt&quot;; # stop simulation and run finish procedure</div>
<div class="line">    $ns run</div>
<div class="line">}</div>
</div><!-- fragment --><p>Optionally, it is good practice to add a finish procedure where display the simulation settings and compute some statistics.</p>
<h1><a class="anchor" id="howmod"></a>
How to add a new module</h1>
<p>In this section we describe how to add a new module in the DESERT core (i.e., into the DESERT_Framework/DESERT directory.) As an example we present the creation of a new module (i.e., a library containing a new DESERT module) named <code>uwcool_phy</code>. The procedure to create a new module is described in the following.</p>
<p>The folder structure aims to follow ISO/OSI structure. First of all, identify where your module can be logically placed and give it a name, in this case, our new <code>uwcool_phy</code> physical layer module should stay inside <code>DESERT_Framework/DESERT/physical</code> folder, therefore you need to cd to that directory and create a folder named <code>uwcool_phy</code>. This folder will contain your new library.</p>
<p>Create two files called <code>uwcoolphy.h</code> and <code>uwcoolphy.cpp</code> files containing your class definition <code>UwCoolPhy</code>. For this class to work, some types of binding are necessary. Moreover you will need to create the following files:</p>
<ul>
<li><code>initlib.cpp</code>,</li>
<li><code>Makefile.am</code>,</li>
<li><code>uwcoolphy-default.tcl</code>.</li>
</ul>
<p>In order to use your class with tcl, in the cpp file you always need to create a <b>static</b> class that derives from <code>TclClass</code> and gives the name that will be used from tcl to create and bind an object of that module. In our example it would be done via the following code:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">class </span>UwCoolPhyClass : <span class="keyword">public</span> TclClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    UwCoolPhyClass()</div>
<div class="line">        : TclClass(<span class="stringliteral">&quot;Module/UW/CoolPhy&quot;</span>)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">    TclObject *</div>
<div class="line">    create(<span class="keywordtype">int</span>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> *)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (<span class="keyword">new</span> UwCoolPhy);</div>
<div class="line">    }</div>
<div class="line">} class_module_uwcoolphy;</div>
</div><!-- fragment --><p>Then we need to link class parameters to tcl variables, this is usually done in the cpp constructor, using the <code>bind()</code> function. This function take as input a string representing a tcl variable which is bound to the second input, which represents a cpp class parameter.</p>
<div class="fragment"><div class="line">bind(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="keywordtype">int</span> *) &amp;debug_);         <span class="comment">// inside uwcoolphy.cpp</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">Module/UW/CoolPhy set debug 1           # inside uwcoolphy-init.tcl</div>
</div><!-- fragment --><p>The <code>initlib.cpp</code> file make <em>the connection</em> between the cpp library of your module and the tcl representing your scenario under simulation/emulation. You need to define an extern variable representing an <b>EmbeddedTcl</b> object, which has a specific name structure: <code>&lt;ModuleNameInCamelCase&gt;&lt;TclCode&gt;</code>. You need also to define a function with fixed naming, which is the name of your module with the first capital letter and <code>_Init</code> suffix. Following our example, your <code>initlib.cc</code> will look like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tclcl.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> EmbeddedTcl UwCoolPhyTclCode;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span></div>
<div class="line">Uwcoolphy_Init()</div>
<div class="line">{</div>
<div class="line">    UwCoolPhyTclCode.load();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>All bound variables need to be initialized to a default value in the <code>uwcoolphy-defaults.tcl</code> file. An example of it would be</p>
<div class="fragment"><div class="line">Module/UW/CoolPhy set BitRate                   32500</div>
<div class="line">Module/UW/CoolPhy set AcquisitionThreshold_dB_  10.0</div>
<div class="line">Module/UW/CoolPhy set debug_                    0</div>
</div><!-- fragment --><p>Finally, to compile your module, you need to fill the <code>Makefile.am</code> file:</p><ul>
<li>There should be the definition of your library. The name of your library should always contain <em>lib</em> prefix, i.e., <code>libuwcoolphy</code>.</li>
<li>Specify the list of sources (<code>libuwcool_phy_la_SOURCES</code>), which should contain only the cpp files located in the <code>uwcool_phy</code> folder.</li>
<li>Remember to define the <code>CPPFLAGS</code>, <code>LDFLAGS</code> and <code>LIBADD</code> where needed.</li>
<li>Define the tcl files variables defaults which are specified inside <code>uwcool-phy-default.tcl</code>.</li>
</ul>
<p>Your <code>Makefile.am</code> should look like this:</p>
<div class="fragment"><div class="line">AM_CXXFLAGS = -Wall -ggdb3</div>
<div class="line"> </div>
<div class="line">lib_LTLIBRARIES = libuwcoolphy.la</div>
<div class="line">libuwcoolphy_la_SOURCES = initlib.cpp uwcoolphy.cpp</div>
<div class="line"> </div>
<div class="line">libuwcoolphy_la_CPPFLAGS = @NS_CPPFLAGS@ @NSMIRACLE_CPPFLAGS@ @DESERT_CPPFLAGS@</div>
<div class="line">libuwcoolphy_la_LDFLAGS =  @NS_LDFLAGS@ @NSMIRACLE_LDFLAGS@ @DESERT_LDFLAGS@</div>
<div class="line">libuwcoolphy_la_LIBADD = @NS_LIBADD@ @NSMIRACLE_LIBADD@ @DESERT_LIBADD@</div>
<div class="line"> </div>
<div class="line">nodist_libuwcoolphy_la_SOURCES = InitTcl.cc</div>
<div class="line">BUILT_SOURCES = InitTcl.cc</div>
<div class="line">CLEANFILES = InitTcl.cc</div>
<div class="line"> </div>
<div class="line">TCL_FILES =  uwcoolphy-default.tcl</div>
<div class="line"> </div>
<div class="line">InitTcl.cc: Makefile $(TCL_FILES)</div>
<div class="line">                cat $(VPATH)/$(TCL_FILES) | @TCL2CPP@ UwCoolPhyTclCode &gt; InitTcl.cc</div>
<div class="line"> </div>
<div class="line">EXTRA_DIST = $(TCL_FILES)</div>
</div><!-- fragment --><p>DESERT compilation and linking is based on autotools, hence to add a new library you need to modify the top-level <code>DESERT_Framework/DESERT/Makefile.am</code> and <code>DESERT_Framework/DESERT/configure.ac</code> files as follows:</p><ul>
<li><code>Makefile.am</code>: we need to add our folder to the subdirectories list (SUBDIRS) using \ as a separator</li>
<li><code>configure.ac</code>: we need to add our new folder to the CPPFLAGS and tell autoconf (AC_CONFIG_FILES) where the new internal Makefile is</li>
</ul>
<div class="fragment"><div class="line">… \</div>
<div class="line">physical/uwcool_phy</div>
</div><!-- fragment --><div class="fragment"><div class="line">[…]</div>
<div class="line">DESERT_CPPFLAGS=&quot;$DESERT_CPPFLAGS &quot;&#39;-I$(top_srcdir)/physical/uwcool_phy&#39;</div>
<div class="line">[…]</div>
<div class="line">AC_CONFIG_FILES=([</div>
<div class="line">[...]</div>
<div class="line">physical/uwcool_phy</div>
<div class="line">[...]</div>
<div class="line">])</div>
</div><!-- fragment --><p>Once everything is ready, we need to reinstall DESERT to properly add the new module.</p>
<p>Note: After the module is installed, we can recompile it without reinstalling everything. In our case, we would need to do the following: </p><div class="fragment"><div class="line">cd DESERT_buildCopy_LOCAL/.buildHost/DESERT/physical/uwcoolphy/</div>
<div class="line">make &amp;&amp; make install</div>
</div><!-- fragment --><h2><a class="anchor" id="cmdMet"></a>
The command method</h2>
<p>Finally, inside a tcl script we can use our module by:</p>
<ol type="1">
<li>Setting its parameter,</li>
<li>instantiating an object,</li>
<li>connecting or calling the necessary methods on it.</li>
</ol>
<p>To set the parameters and instantiate the object we can write</p>
<div class="fragment"><div class="line">Module/UW/CoolPhy set BitRate_                 32500</div>
<div class="line">Module/UW/CoolPhy set AcquisitionThreshold_dB_ 10.0</div>
<div class="line"> </div>
<div class="line">set phy [new Module/UW/CoolPhy]</div>
</div><!-- fragment --><p>To enable the communciation between the cpp class and the tcl script we need to overwrite the command method, for example to get and set parameters of a module object. It must be declared in this way, in your module class (<code>uwcoolphy.h</code>)</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">int</span> command(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> *argv);</div>
</div><!-- fragment --><p> And then it should be defined in this way (inside <code>uwcoolphy.cpp</code>)</p>
<div class="fragment"><div class="line">UwCoolPhy::command(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keyword">const</span> *argv) {</div>
<div class="line">    <span class="keywordflow">if</span> (argc == 2) {</div>
<div class="line">        <span class="keywordflow">if</span> (strcmp(argv[1], <span class="stringliteral">&quot;Method1&quot;</span>) == 0) {</div>
<div class="line">            method1();</div>
<div class="line">            <span class="keywordflow">return</span> TCL_OK;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argc == 3) { .... }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> Module::command(argc, argv)</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="pLog"></a>
The printOnLog method</h2>
<blockquote class="doxtable">
<p>NOTE: This is a new feature (version &gt;= 3.6). By now only the following modules implement it:</p>
<ul>
<li><a class="el" href="classUwCbrModule.html" title="UwCbrModule class is used to manage UWCBR packets and to collect statistics about them.">UwCbrModule</a></li>
<li><a class="el" href="classUwUdp.html" title="UwUdp class is used to manage UWUDP packets, and flows to and from upper modules.">UwUdp</a></li>
<li><a class="el" href="classUWIPModule.html" title="UWIPModule class is used to define the Internet Protocol (IP) layer of a node.">UWIPModule</a></li>
<li><a class="el" href="classUwStaticRoutingModule.html" title="UwStaticRoutingModule class implements basic routing functionalities.">UwStaticRoutingModule</a></li>
<li><a class="el" href="classCsmaAloha.html" title="Class that describes a CsmaAloha module.">CsmaAloha</a></li>
<li><a class="el" href="classUnderwaterPhysical.html">UnderwaterPhysical</a></li>
</ul>
<p>All the other modules use the ns-way of logging: You need to define a <code>debug_</code> parameter on your module and bind it to tcl inside the constructor (see the previous section). Every time you want to print a log message, then you need to check if debug parameter is set and print to console your message. </p>
</blockquote>
<p>Each DESERT module inherits a static logger parameter, shared among all the modules in a simulation istance. It lets you specify the level of logging messages you want. There are three possible values:</p>
<p><small> </p><pre class="fragment"> ERROR: only error messages will be generated.
 INFO : general info about the algorithms running and also ERROR messages.
 DEBUG: details that allow to understand the execution flow plus both ERROR and INFO messages are shown.
</pre><p> </small></p>
<p>In particular, it gives you the method <code>printOnLog</code>, defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> printOnLog(Logger::LogLevel level, <span class="keyword">const</span> std::string &amp;module, <span class="keyword">const</span> std::string &amp;message) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>This method takes three parameter: (i) the log level of the message, (ii) the name of the module printing the message and (iii) a string representing the log message.</p>
<p>As an example, suppose you have a method to handle packets reception that you would like to track, you can do it as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">UwCoolPhy::startRx(Packet *p)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    printOnLog(Logger:LogLevel:<a class="code hl_define" href="uwtokenbus_8cpp.html#ad16d11af5dda4cba62965cd3fc156a6e">DEBUG</a>, <span class="stringliteral">&quot;UWCOOLPHY&quot;</span>, <span class="stringliteral">&quot;startRX(Packet *)::Received new packet&quot;</span>);</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="auwtokenbus_8cpp_html_ad16d11af5dda4cba62965cd3fc156a6e"><div class="ttname"><a href="uwtokenbus_8cpp.html#ad16d11af5dda4cba62965cd3fc156a6e">DEBUG</a></div><div class="ttdeci">#define DEBUG(level, text)</div><div class="ttdef"><b>Definition</b> <a href="uwtokenbus_8cpp_source.html#l00049">uwtokenbus.cpp:49</a></div></div>
</div><!-- fragment --><p>To enable and configure the log messages in your simulation, you can use the following commands:</p>
<div class="fragment"><div class="line">setLogLevel &lt;log_level&gt;             <span class="comment">// Set the logger level (1, 2 or 3)</span></div>
<div class="line">setLogFile  &lt;file_name&gt;             <span class="comment">// Set the logger file name</span></div>
<div class="line">setLog      &lt;log_level&gt; &lt;file_name&gt; <span class="comment">// Set both the logger level and file name</span></div>
<div class="line">enableLog                           <span class="comment">// Enable log on a specific module</span></div>
<div class="line">disableLog                          <span class="comment">// Disable log on a specific module</span></div>
</div><!-- fragment --><p>Remember that all the modules in a given simulation, share the same instance of the logger, meaning, that the <code>log_level</code> and <code>log_file</code> can be set just once. For instance, suppose, you have a tcl file, with one transmitting node and one sink node, you can set the logger for the sink physical layer only as follows:</p>
<div class="fragment"><div class="line">proc createSink { } {</div>
<div class="line">    ...</div>
<div class="line">    set phy_data_sink [new Module/UW/CoolPhy]</div>
<div class="line">    ....</div>
<div class="line">    $phy_data_sink setLog 3 &quot;log_output.txt&quot;</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>It will print all the <code>coolphy</code> log messages inside a file called <code>log_output.txt</code>. Each message has an <code>id</code> associated with it, which is the ns id of the node and is incremental set, e.g., the first node created will have <code>id</code> 0, the second <code>id</code> 1 and so on.</p>
<p>Note: You can find a complete example on how to use the logging system inside <code>DESERT/samples/desert_samples/logger/</code> folder.</p>
<h1><a class="anchor" id="newheader"></a>
How to add a new Packet headers</h1>
<p>In the case your module needs its own <b>packet header</b>, a few things need to be performed:</p>
<p>Define a header <em>struct</em>, for example <code>hdr_uwmyprotocol</code> inside a file <code>myproto-hdr.h</code> with your parameters plus the offset field required by the <em>packet header manager</em>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>hdr_uwmyprotocol </div>
<div class="line">{</div>
<div class="line">    uint8_t param;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">int</span> offset_;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> uint8_t &amp; param() { <span class="keywordflow">return</span> param_ }</div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span>&amp; offset() {<span class="keywordflow">return</span> offset_;}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keyword">struct </span>hdr_uwmyprotocol *</div>
<div class="line">    access(<span class="keyword">const</span> Packet *p)</div>
<div class="line">    { </div>
<div class="line">        <span class="keywordflow">return</span> (<span class="keyword">struct</span> hdr_uwmyprotocol *) p-&gt;access(offset_); </div>
<div class="line">    }</div>
<div class="line">} hdr_uwmyprotocol;</div>
</div><!-- fragment --><p>To simplify the access of your <em>header</em> from the <em>packet</em> class, at the beginning of the source file where your header is defined you can define the following macro</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define HDR_UWMYPROTOCOL(p) (hdr_uwmyprotocol::access(p))</span></div>
</div><!-- fragment --><p>Just after the macro, at the beginning of the file, you need to define a new <em>packet</em> type with</p>
<p><small> </p><pre class="fragment">extern packet_t PT_MYPACKET;
</pre><p> </small></p>
<p>Inside initlib.cpp you need to</p><ul>
<li>Include your header file and define the offset and the packet type</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;myproto-hdr.h&gt;</span></div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">int hdr_uwmyprotocol::ofset_;</div>
<div class="line">packet_t PT_MYPACKET;</div>
</div><!-- fragment --><ul>
<li>Add a static class</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">class </span>MyProtoHeaderClass : <span class="keyword">public</span> PacketHeaderClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyProtoHeaderClass()</div>
<div class="line">        : PacketHeaderClass(<span class="stringliteral">&quot;PacketHeader/MYPROTO&quot;</span>, sizeof(hdr_uwmyprotocol))</div>
<div class="line">    {</div>
<div class="line">        this-&gt;bind();</div>
<div class="line">        bind_offset(&amp;hdr_uwmyprotocol::offset_);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Add the packet inside the <code>init</code> function (before the <code>load</code> function call), using the same name of the extern</li>
</ul>
<div class="fragment"><div class="line">PT_MYPACKET = p_info::addPacket(<span class="stringliteral">&quot;MYPROTO&quot;</span>);</div>
</div><!-- fragment --><p>Finally, inside the *-default.tcl you need to add the packet to the packet manager, with</p>
<div class="fragment"><div class="line">PacketHeaderManager set tab_(PacketHeader/MYPROTO) 1</div>
</div><!-- fragment --><p>This last step is really important to have the right memory allocation done. Missing it could lead to unpredictable behavior, usually really hard to troubleshoot.</p>
<h1><a class="anchor" id="newaddon"></a>
How to add a new DESERT Add-on</h1>
<p>In this section we describe how to add a new module as a DESERT addon. An addon, is an external autotools project that depends on DESERT, ns-miracle and, in some cases, WOSS or even other addons, so we don’t need to modify the DESERT toplevel <code>Makefile.am</code> and <code>configure.ac</code>. We need to create just the addon internal <code>Makefile.am</code> and a dedicated <code>configure.ac</code> with <code>m4</code> folder to resolve the dependencies. The complete procedure is described in the following.</p>
<p>Inside the <code>DESERT_Addons</code> folder, create your addon folder, say <code>cool-addon</code>. Inside that folder, create the basic files for a properly cpp module, i.e., <code>cool-addon.h</code> and <code>cool-addon.cpp</code> and the <code>initlib.cpp</code> as well.</p>
<p>Similarly to what you did for the adding a module, your <code>initlib.cpp</code> will look like</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tclcl.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> EmbeddedTcl CoolAddonTclCode;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span></div>
<div class="line">Cooladdon_Init()</div>
<div class="line">{</div>
<div class="line">    CoolAddonTclCode.load();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To make the addon compilable and complete, we also need:</p><ul>
<li>A <code>Makefile.am</code>,</li>
<li>a <code>configure.ac</code> config file,</li>
<li>an initialization file for the tcl, i.e., <code>cool-addon-init.tcl</code>,</li>
<li>the <code>autogen.sh</code> script,</li>
<li>and a <code>m4</code> folder</li>
</ul>
<p>The <code>Makefile.am</code> can be taken from another addon or module and modified according to your addond needs, similarly to what what we did for a module. Just note that in case of a <em>WOSS</em> dependent addon, it is better to take the <code>Makefile.am</code> from another <em>WOSS</em>-based addon, such as <code>wossgmmob3D</code> or <code>wossgroupmob3D</code>. Similarly, in case your addon is based on another existing addon, take it from <code>uwswarm_control</code> or <code>ms2c_evologics_lowlev</code> addons.</p>
<p>Also for the <code>configure.ac</code> you take one from another addon and copy into your folder. You just need to modify the <code>AC_INIT</code> with the name of your addon. Also in this case if you need WOSS functionalities take it from a WOSS-based addon.</p>
<p>The <code>autogen.sh</code> file is needed to compile your addon and can be copied from any other addon and doesn't need any modification.</p>
<p>Add all the variables that you have <em>binded</em> in your addon class inside the <code>cool-addon-init.tcl</code> files as youd did for the module.</p>
<p>The <code>m4</code> folder contains the <code>desert.m4</code> file and the <code>desertAddon.m4</code> and <code>woss.m4</code> files if the addon depend from another addon or woss. Also in this case, it is easier to copy from another addon and modify the dependencies wee ned for our addon. Those are directories listed in <code>dir</code> and <code>lib</code> portion of the given <code>m4</code> file.</p>
<p>Finally, to have your addon visible during installation, modify the installation file <code>DESERT_Framework/.addon.list</code> adding the name of your addon folder.</p>
<h1><a class="anchor" id="HowTo"></a>
How to add a new custom installer</h1>
<blockquote class="doxtable">
<p>NOTE: When you see a pathname preceded by three dots, this refers to a well-known but unspecified top-level directory. The top-level directory is context-dependent, but almost always refers to top-level DESERT source directory. For example, <code>.../DESERT_Underwater/DESERT_Framework/Installer/installDESERT_LOCAL.sh</code> refers to the <code>installDESERT_LOCAL.sh</code> file located in the architecture branch of a DESERT framework source tree. The actual path might be something like <code>/home/foo/DESERT_Underwater/DESERT_Framework/Installer/installDESERT_LOCAL.sh</code>. </p>
</blockquote>
<p>First of all, enter the installation folder:</p>
<div class="fragment"><div class="line">cd .../DESERT_Underwater/DESERT_Framework/Installation/</div>
</div><!-- fragment --><p>Now, create a new script. We suggest to copy an existing installation script (e.g. <code>installDESERT_LOCAL.sh</code>):</p>
<div class="fragment"><div class="line">cp installDESERT_LOCAL.sh installDESERT_&lt;your-custom-installation-target&gt;.sh</div>
</div><!-- fragment --><p>Please note the <code>&lt;your-custom-installation-target&gt;</code> label: this will be the same parameter you will pas later as an option to the installation script when indicating which installation-target to choose. We remark that these steps are very easy but also very important, since the only way to call the correct installation script for <code>&lt;your-custom-installation-target&gt;</code> is that the script <code>installDESERT_&lt;your-custom-installation-target&gt;.sh</code> exists in the folder <code>.../DESERT_Underwater/DESERT_Framework/Installation/</code></p>
<p>Let us now have a deeper look at the script. We focus first on the main block:</p>
<div class="fragment"><div class="line">main() {</div>
<div class="line">    #******************************************************************************</div>
<div class="line">    # MAIN</div>
<div class="line">    #     e.g handle_package host/target &lt;pkt-name&gt;</div>
<div class="line">    #     e.g addon_installation_list host/target &lt;addon-list&gt;</div>
<div class="line"> </div>
<div class="line">    ## only for the cross-compilation session</div>
<div class="line">    export CROSS_ENV_DIR=&quot;&quot;</div>
<div class="line">    export CROSS_ENV_FILE=&quot;&quot;</div>
<div class="line">    #*</div>
<div class="line"> </div>
<div class="line">    handle_package host ZLIB</div>
<div class="line">    handle_package host TCL</div>
<div class="line">    export PATH=${BUILD_HOST}/bin:$PATH</div>
<div class="line">    export LD_LIBRARY_PATH=${BUILD_HOST}/lib</div>
<div class="line">    handle_package host OTCL</div>
<div class="line">    handle_package host TCLCL</div>
<div class="line">    handle_package host NS</div>
<div class="line">    handle_package host NSMIRACLE</div>
<div class="line">    handle_package host DESERT</div>
<div class="line">    if [ ${WITHWOSS} -eq 1 ]; then</div>
<div class="line">        handle_package host NETCDF</div>
<div class="line">        handle_package host NETCDFCXX</div>
<div class="line">        handle_package host BELLHOP</div>
<div class="line">        handle_package host WOSS</div>
<div class="line">    fi</div>
<div class="line">    if [ ! -z &quot;${ADDONS}&quot; ]; then</div>
<div class="line">        addon_installation_list host &quot;${ADDONS}&quot;</div>
<div class="line">    fi</div>
<div class="line">    #******************************************************************************</div>
<div class="line">}</div>
</div><!-- fragment --><p>Notice the <em><b>host</b></em> directive. This tells the installation script to compile the libraries for the current host. If you need to modify this script to cross-compile for a different target, substitute all lines with the following ones:</p>
<div class="fragment"><div class="line">main() {</div>
<div class="line">    #******************************************************************************</div>
<div class="line">    # MAIN</div>
<div class="line">    #     e.g handle_package host/target &lt;pkt-name&gt;</div>
<div class="line">    #     e.g addon_installation_list host/target &lt;addon-list&gt;</div>
<div class="line"> </div>
<div class="line">    ## only for the cross-compilation session</div>
<div class="line">    export CROSS_ENV_DIR=&quot;&lt;YOUR/ENVIRONMENT/FOLDER/PATH&gt;&quot;</div>
<div class="line">    export CROSS_ENV_FILE=&quot;${CROSS_ENV_DIR}/environment&quot;</div>
<div class="line">    #*</div>
<div class="line"> </div>
<div class="line">    handle_package host/target ZLIB</div>
<div class="line">    handle_package host/target TCL</div>
<div class="line">    export PATH=&quot;${BUILD_HOST}/bin:$PATH&quot;</div>
<div class="line">    export LD_LIBRARY_PATH=&quot;${BUILD_HOST}/lib&quot;</div>
<div class="line">    handle_package host/target OTCL</div>
<div class="line">    handle_package host/target TCLCL</div>
<div class="line">    handle_package target NS</div>
<div class="line">    handle_package target NSMIRACLE</div>
<div class="line">    handle_package target DESERT</div>
<div class="line">    if [ ${WITHWOSS} -eq 1 ]; then</div>
<div class="line">        #handle_package target NETCDF</div>
<div class="line">        #handle_package target NETCDFCXX</div>
<div class="line">        #handle_package target BELLHOP</div>
<div class="line">        #handle_package target WOSS</div>
<div class="line">        warn_L1 &quot;The WOSS libreries wont be installed!&quot;</div>
<div class="line">    fi</div>
<div class="line">    if [ ! -z &quot;${ADDONS}&quot; ]; then</div>
<div class="line">        addon_installation_list target &quot;${ADDONS}&quot;</div>
<div class="line">    fi</div>
<div class="line">    #******************************************************************************</div>
<div class="line">}</div>
</div><!-- fragment --><p>With these changes we instructed the installer to compile some modules only for the host, some for both the host and the target and the remaining ones only for the target (<em><b>target</b></em> directive). This step is crucial, because some libraries must be compiled for the host, in order to correctly cross-compile DESERT and its addons for <code>&lt;your-custom-installation-target&gt;</code>.</p>
<p><small> </p><pre class="fragment">WARNING: be careful NOT TO CONFUSE the directive "target" with "&lt;tt&gt;&lt;your-custom-installation-target&gt;&lt;/tt&gt;".
         The former is just a directive to the &lt;tt&gt;handle_package&lt;/tt&gt; function of the installation script.
</pre><p> </small></p>
<p>We remark that you need the <b>TOOLCHAIN</b> of <code>&lt;your-custom-installation-target&gt;</code> in order to correctly complete the installation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
