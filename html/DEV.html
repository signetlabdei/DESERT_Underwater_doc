<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DESERT: Developer guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DESERT
   &#160;<span id="projectnumber">3.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('DEV.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Developer guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="DESMod"></a>
Structure of a DESERT module</h1>
<p>Each DESERT module derives either from another DESERT or ns-miracle module (e.g., <a class="el" href="classUnderwaterPhysical.html">UnderwaterPhysical</a> derives from ns2-miracle UnderwaterMPhyBpsk) or from the base ns2-miracle Module class. In order to use it with tcl, in the cpp file you always need to create a static class that derives from TclClass and gives the name that will be used from tcl to create and bind an object of that module. For instance <a class="el" href="classUnderwaterPhysical.html">UnderwaterPhysical</a> is “converted” in tcl using the following class</p>
<p><small> </p><pre class="fragment">static class UwPhysicalClass : public TclClass
{
public:
    UwPhysicalClass()
        : TclClass("Module/UW/PHYSICAL")
    {
    }
    TclObject *
    create(int, const char *const *)
    {
        return (new UnderwaterPhysical);
    }
} class_module_uwphysical;
</pre><p> </small></p>
<p>The name "Module/UW/PHYSICAL" is the one that will be used in TCL to create and bind objects of type <a class="el" href="classUnderwaterPhysical.html">UnderwaterPhysical</a>.</p>
<p>You can pass variables to and from tcl script and C++ class, by means of bind function, inside the constructor of your module class. To bind a variable you need to use the bind function inside the constructor of your module class. In example, in <a class="el" href="classUnderwaterPhysical.html">UnderwaterPhysical</a> we bind the rx_power_ with bind("rx_power_consumption_", &amp;rx_power_); All bound variables need to be initialized to a default value in the *-defaults.tcl inside your folder.</p>
<p>Another way to communicate with the tcl script is to overwrite the command method, for example to get and set parameters of a module object. For more details, just check the <a class="el" href="classUnderwaterPhysical.html#aec051803a5f4aa6fd2e8ff40a5ef411a" title="TCL command interpreter.">UnderwaterPhysical::command</a> method. It is usually best practice to call the father class’ command method at the end.</p>
<h1><a class="anchor" id="HowTo"></a>
How to add a new custom installer</h1>
<p>First of all, enter the installation folder:</p>
<p><small> </p><pre class="fragment">cd .../DESERT_Underwater/DESERT_Framework/Installation/
</pre> <blockquote class="doxtable">
<p>NOTE: When you see a pathname preceded by three dots, this refers to a well-known but unspecified top-level directory. The top-level directory is context-dependent, but almost universally refers to top-level DESERT source directory. For example, <code>.../DESERT_Underwater/DESERT_Framework/Installer/installDESERT_PC.sh</code> refers to the <code>installDESERT_PC.sh</code> file located in the architecture branch of a DESERT framework source tree. The actual path might be something like <code>/home/foo/DESERT_Underwater/DESERT_Framework/Installer/installDESERT_PC.sh</code>. </p>
</blockquote>
<p></small></p>
<p>At this point, create a new script. We suggest to copy an existing installation script (e.g. <code>installDESERT_PC.sh</code>):</p>
<p><small> </p><pre class="fragment">cp installDESERT_PC.sh installDESERT_&lt;your-custom-installation-target&gt;.sh
</pre><p> </small></p>
<p>Please note the <code>&lt;your-custom-installation-target&gt;</code> label: this will be the same parameter you will pas later as an option to the installation script when indicating which installation-target to choose. We remark that these steps are very easy but also very important, since the only way to call the correct installation script for <code>&lt;your-custom-installation-target&gt;</code> is that the script <code>installDESERT_&lt;your-custom-installation-target&gt;.sh</code> exists in the folder <code>.../DESERT_Underwater/DESERT_Framework/Installation/</code></p>
<p>Let us now have a deeper look at the script. We focus first on the main block:</p>
<p><small> </p><pre class="fragment">main() {
    #******************************************************************************
    # MAIN
    #     e.g handle_package host/target &lt;pkt-name&gt;
    #     e.g addon_installation_list host/target &lt;addon-list&gt;

    ## only for the cross-compilation session
    export CROSS_ENV_DIR=""
    export CROSS_ENV_FILE=""
    #*

    handle_package host ZLIB
    handle_package host TCL
    export PATH=${BUILD_HOST}/bin:$PATH
    export LD_LIBRARY_PATH=${BUILD_HOST}/lib
    handle_package host OTCL
    handle_package host TCLCL
    handle_package host NS
    handle_package host NSMIRACLE
    handle_package host DESERT
    if [ ${WITHWOSS} -eq 1 ]; then
        handle_package host NETCDF
        handle_package host NETCDFCXX
        handle_package host BELLHOP
        handle_package host WOSS
    fi
    if [ ! -z "${ADDONS}" ]; then
        addon_installation_list host "${ADDONS}"
    fi
    #******************************************************************************
}
</pre><p> </small></p>
<p>Notice the "host" directive. This tells the installation script to compile the libraries for the current host. If you need to modify this script to cross-compile for a different target, substitute all lines with the following ones:</p>
<p><small> </p><pre class="fragment">main() {
    #******************************************************************************
    # MAIN
    #     e.g handle_package host/target &lt;pkt-name&gt;
    #     e.g addon_installation_list host/target &lt;addon-list&gt;

    ## only for the cross-compilation session
    export CROSS_ENV_DIR="&lt;YOUR/ENVIRONMENT/FOLDER/PATH&gt;"
    export CROSS_ENV_FILE="${CROSS_ENV_DIR}/environment"
    #*

    handle_package host/target ZLIB
    handle_package host/target TCL
    export PATH="${BUILD_HOST}/bin:$PATH"
    export LD_LIBRARY_PATH="${BUILD_HOST}/lib"
    handle_package host/target OTCL
    handle_package host/target TCLCL
    handle_package target NS
    handle_package target NSMIRACLE
    handle_package target DESERT
    if [ ${WITHWOSS} -eq 1 ]; then
        #handle_package target NETCDF
        #handle_package target NETCDFCXX
        #handle_package target BELLHOP
        #handle_package target WOSS
        warn_L1 "The WOSS libreries wont be installed!"
    fi
    if [ ! -z "${ADDONS}" ]; then
        addon_installation_list target "${ADDONS}"
    fi
    #******************************************************************************
}
</pre><p> </small></p>
<p>With these changes we instructed the installer to compile some modules only for the host ("host" directive), some for both the host and the target ("host/target" directive) and the remaining ones only for the target ("target" directive). This step is crucial, because some libraries must be compiled for the host, in order to correctly cross-compile DESERT and its addons for <code>&lt;your-custom-installation-target&gt;</code>.</p>
<p><small> </p><pre class="fragment">WARNING: be careful NOT TO CONFUSE the directive "target" with "&lt;tt&gt;&lt;your-custom-installation-target&gt;&lt;/tt&gt;".
         The former is just a directive to the &lt;tt&gt;handle_package&lt;/tt&gt; function of the installation script.
</pre><p> </small></p>
<p>We remark that you need the <b>TOOLCHAIN</b> of <code>&lt;your-custom-installation-target&gt;</code> in order to correctly complete the installation.</p>
<h1><a class="anchor" id="newmod"></a>
How to add a new DESERT module</h1>
<p>In this section we describe how to add a new module in the DESERT core (i.e., into the DESERT_Framework/DESERT directory.) As an example we present the creation of a new module (i.e., a library containing a new DESERT module) named uwcool_phy. The procedure to create a new module is described as follows:</p><ul>
<li>The folder structure aims to follow ISO/OSI structure. Identify where your module can be logically placed and give it a name ( i.e., our new uwcool_phy physical layer module should stay inside DESERT_Framework/DESERT/physical, therefore you need to create a folder DESERT_Framework/DESERT/physical/uwcool_phy: this folder will contain your new library.</li>
<li>Add your .h and .cpp files containing your class definition, called, for instance UwCoolPhy: this point will be discussed more in detail later.</li>
<li>Add the file initlib.cpp: this file is really standard and you can use an existing one (i.e., an existing physical layer module) as an example. This is the file that make “the connection” between the C++ library of your module and the tcl representing your scenario under simulation/emulation. You need to define an extern variable representing an EmbeddedTcl object, which has a specific name structure: &lt;ModuleNameInCameCase&gt;&lt;InitTclCode&gt;. You need also to define a function with fixed naming, which is the name of your module with the first capital letter and _Init suffix Following our example, the variable should be named UwCoolPhyInitTclCode and the function should be Uwcoolphy_Init. Some of those initlib files has also support to Cygwin. If you are not planning to use it, you can get rid of it.</li>
<li>Add the tcl for default initialization, called uwcool-phy-default.tcl, which will contain the initialization of your tcl binded variables. You can take a look at uwphysical module to have an example of it</li>
<li>Add to your folder the internal Makefile.am: here there should be the definition of your library. The name of your library should always contain lib prefix, i.e. libuwcoolphy. Since the structure of the Makefiles is really standard you can take, for example, the uwphysical module’s one and modify some parts of it: the word libuwphysical should be changed EVERYWHERE with the name of your library, e.g., libuwcoolphy the word UwPhysicalInitTclCode should be changed to UwCoolPhyInitTclCode the list of sources (libuwcool_phy_la_SOURCES) should contain only the cpp files located in the uwcool_phy folder the TCL_FILES should be equal to uwcool-phy-default.tcl</li>
<li>Modify top-level Makefile.am and configure.ac: DESERT compilation and linking is based on autotools, hence to add a new library you need to modify and DESERT_Framework/DESERT/Makefile.am and DESERT_Framework/DESERT/configure.ac as follows:<ol type="1">
<li>Makefile.am: we need to add our folder to the subdirectories list (SUBDIS) using \ as a separator <small> <pre class="fragment">… \
    physical/uwcool_phy
</pre> </small></li>
<li>configure.ac: we need to add our new folder to the CPPFLAGS and tell autoconf (AC_CONFIG_FILES) where the new internal Makefile is <small> <pre class="fragment">[…]
DESERT_CPPFLAGS="$DESERT_CPPFLAGS "'-I$(top_srcdir)/physical/uwcool_phy'
[…]
AC_CONFIG_FILES=([
[...]
physical/uwcool_phy
[...]
])
</pre> </small></li>
</ol>
</li>
</ul>
<h1><a class="anchor" id="newaddon"></a>
How to add a new DESERT Add-on</h1>
<p>In this section we describe how to add a new module as a DESERT add-on, inside the folder DESERT_Addons. An addon is an external autotools project that depends on DESERT, ns2miracle and, in some cases, WOSS, so we don’t need to modify the DESERT toplevel Makefile.am and configure.ac, but we need to create just the addon internal Makefile.am and a dedicated configure.ac with m4 folder to resolve the dependencies. The complete procedure is described as follows.</p><ul>
<li>Add your folder inside DESERT_Addons/</li>
<li>Add your .h and .cpp files like in point 2 of the previous section</li>
<li>Add iniltib.cpp like in point 3 of the previous section</li>
<li>Add the tcl file for the default initialization of your module like in point 3 of the previous section</li>
<li>Add the Makefile.am like in point 5 of the previous section</li>
<li>add in your folder the file autogen.sh: you can copy and paste is from another addon: this file should not be modified</li>
<li>copy from another addon the file configure.ac and modify the AC_INIT writing the name of your module, e.g., . In the case your module uses WOSS, copy the configure.ac from an addon that uses WOSS as well (e.g., wossgmmob3D), otherwise copy it from an addon that does not (e.g., one of the packer)</li>
<li>copy the folder m4 from another addon</li>
<li>inside the folded m4, change desert.m4 according to the DESERT dependencies of your module. e.g., you need to list in dir and in lib the directories and libraries your module uses.</li>
<li>in the case your module uses some woss dependencies, you need to do the same with woss.m4</li>
</ul>
<h1><a class="anchor" id="newheader"></a>
How to add a new Packet headers</h1>
<p>In the case your module needs its own packet header, a few things need to be performed: define a header struct, for example hdr_MY inside a file my_hdr.h with your parameters plus the following members:</p>
<p><small> </p><pre class="fragment">public static int offser_ member 
inline static int&amp; offset() {return offset_;}
inline static struct hdr_MY * access(const Packet *p) { 
return (struct hdr_MY *) p-&gt;access(offset_); 
}
</pre><p> </small></p>
<p>to simplify the access of your header from the packet, at the beginning of the source file where your header is defined you can define a macro</p>
<p><small> </p><pre class="fragment">define HDR_MY(p) (hdr_MY::access(p))
</pre><p> </small></p>
<p>just after the macro, at the beginning of the file, you need to define a new packet type with</p>
<p><small> </p><pre class="fragment">extern packet_t PT_MY;
</pre><p> </small></p>
<p>Inside initlib.cpp you need to</p>
<ul>
<li>add a static class</li>
</ul>
<p><small> </p><pre class="fragment">static class MY_HeaderClass : public PacketHeaderClass
{
public:
    MY_HeaderClass()
        : PacketHeaderClass("PacketHeader/MY", sizeof(hdr_MY))
    {
        this-&gt;bind();
        bind_offset(&amp;hdr_MY::offset_);
    }
} class_MY_HeaderClass;
</pre><p></small></p>
<p><small></small></p>
<ul>
<li>add the packet in the init function (before the load), using the same name of the extern</li>
</ul>
<p><small> </p><pre class="fragment">PT_MY = p_info::addPacket("UWPROTOCOL/MY");
</pre><p> </small></p>
<p>where PROTOCOL is the name of the protocol</p>
<p>Finally, inside the *-default.tcl you need to add the packet to the packet manager, with</p>
<p><small> </p><pre class="fragment">PacketHeaderManager set tab_(PacketHeader/MY) 1
</pre><p> </small></p>
<p>This last step is really important to have the right memory allocation done. Missing it could lead to unpredictable behavior, usually really hard to troubleshoot. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
